dftointerpolate
dfinterpolated
dfinterpolated <- do.call(cbind,dftointerpolate)
dfinterpolated
dfinterpolated <- tbl_df(do.call(cbind,dftointerpolate))
dfinterpolated
dfinterpolated
dfinterpolated
dftointerpolate <- df[index$n,
as.character(
stringr::str_split(missingdata$x[i],pattern = ";",
simplify = T))]
# ENSURE WE DON'T HAVE EMPTY COLUMNS
dftointerpolate <- dftointerpolate[!check.emptycolumn(dftointerpolate)]
# INTERPOLATE USING ZOO PACKAGE
dfinterpolated <- lapply(1:ncol(dftointerpolate), function(j)
zoo::na.approx(dftointerpolate[,j],rule = 2))
dfinterpolated <- tbl_df(do.call(cbind,dfinterpolated))
dfinterpolated
dftointerpolate
dftointerpolate[,j]
is.na(dftointerpolate[,j])
as.numeric(is.na(dftointerpolate[,j]))
# CODING WE WILL USE FOR MATRIX STORING WHETHER DATA HAVE BEEN INTERPOLATE:
# NA = NOT USED FOR INTERPOLATION
# 0  = NOT INTERPOLATED BUT USED TO FILL OTHER VALUES
# 1  = INTERPOLATED
as.numeric(is.na(dftointerpolate[,j]))
dftointerpolate <- sapply(1:ncol(dftointerpolate), function(j)
as.numeric(is.na(dftointerpolate[,j])))
dftointerpolate
dftointerpolate
dfinterpolated
dftointerpolate
dfinterpolated
index$n
list(lines = index$n, cols = as.character(
stringr::str_split(missingdata$x[i],pattern = ";",
simplify = T)),
before = dftointerpolate,
after = dfinterpolated)
interpolate_group <- function(missingdata,i = 1){
# RECOVERING GROUPS
groupsvar <- missingdata %>% group_vars()
# ROWS THAT WILL BE CHANGED
index <- df[,groupsvar] %>% ungroup() %>%
dplyr::mutate(n = row_number()) %>%
filter_(paste(groupsvar,"==","'",missingdata[i,groupsvar],
"'", sep = "",
collapse = "&"))
# EXTRACT ROWS AND COLUMNS CONCERNED
dftointerpolate <- df[index$n,
as.character(
stringr::str_split(missingdata$x[i],pattern = ";",
simplify = T))]
# ENSURE WE DON'T HAVE EMPTY COLUMNS
dftointerpolate <- dftointerpolate[!check.emptycolumn(dftointerpolate)]
# INTERPOLATE USING ZOO PACKAGE
dfinterpolated <- lapply(1:ncol(dftointerpolate), function(j)
zoo::na.approx(dftointerpolate[,j],rule = 2))
dfinterpolated <- tbl_df(do.call(cbind,dfinterpolated))
# CODING WE WILL USE FOR MATRIX STORING WHETHER DATA HAVE BEEN INTERPOLATE:
# NA = NOT USED FOR INTERPOLATION
# 0  = NOT INTERPOLATED BUT USED TO FILL OTHER VALUES
# 1  = INTERPOLATED
dftointerpolate <- sapply(1:ncol(dftointerpolate), function(j)
as.numeric(is.na(dftointerpolate[,j])))
resultinterpol <- list(lines = index$n, cols = as.character(
stringr::str_split(missingdata$x[i],pattern = ";",
simplify = T)),
after = dfinterpolated,
change = dftointerpolate)
return(resultinterpol)
}
interpolate_group
missingdata
missingdata <- count_NAs(df = df, groupingvar = groupingvar)
missingdata <- missingdata %>% filter(p<threshold & p > 0)
missingdata <-  missingdata %>% select(-p) %>%
group_by_(.dots = groupingvar) %>%
dplyr::mutate(x = paste(.$varia, collapse = ";")) %>%
slice(1)
missingdata
lapply(1:nrow(missingdata), function(i)
interpolate_group(missingdata,i))
missingdata
1:nrow(missingdata)
i = 1
interpolate_group(missingdata,i)
i = 2
interpolate_group(missingdata,i)
i = 3
interpolate_group(missingdata,i)
i = 4
interpolate_group(missingdata,i)
i = 4
groupsvar <- missingdata %>% group_vars()
# ROWS THAT WILL BE CHANGED
index <- df[,groupsvar] %>% ungroup() %>%
dplyr::mutate(n = row_number()) %>%
filter_(paste(groupsvar,"==","'",missingdata[i,groupsvar],
"'", sep = "",
collapse = "&"))
dftointerpolate <- df[index$n,
as.character(
stringr::str_split(missingdata$x[i],pattern = ";",
simplify = T))]
dftointerpolate
# ENSURE WE DON'T HAVE EMPTY COLUMNS
dftointerpolate <- dftointerpolate[!check.emptycolumn(dftointerpolate)]
dftointerpolate
complete.cases(dftointerpolate)
complete.cases(dftointerpolate[,i])
j
complete.cases(dftointerpolate[,j])
!is.na(dftointerpolate[,j])
sum(!is.na(dftointerpolate[,j]))
dftointerpolate
names(dftointerpolate)
sapply(names(dftointerpolate), function(nam) sum(!is.na(dftointerpolate[,nam]))
# INTERPOLATE USING ZOO PACKAGE
dfinterpolated <- lapply(1:ncol(dftointerpolate), function(j)
zoo::na.approx(dftointerpolate[,j],rule = 2))
dfinterpolated <- tbl_df(do.call(cbind,dfinterpolated))
# CODING WE WILL USE FOR MATRIX STORING WHETHER DATA HAVE BEEN INTERPOLATE:
# NA = NOT USED FOR INTERPOLATION
# 0  = NOT INTERPOLATED BUT USED TO FILL OTHER VALUES
# 1  = INTERPOLATED
dftointerpolate <- sapply(1:ncol(dftointerpolate), function(j)
as.numeric(is.na(dftointerpolate[,j])))
# STORE IN LIST EVERYTHING THAT IS NEEDED
resultinterpol <- list(lines = index$n, cols = as.character(
stringr::str_split(missingdata$x[i],pattern = ";",
simplify = T)),
after = dfinterpolated,
change = dftointerpolate)
return(resultinterpol)
}
interpolate_data <- function(df,groupingvar = 'Country_Transco',
threshold = 0.6){
# DATAFRAME SUMMING UP THE CHANGE WE WILL DO
missingdata <- count_NAs(df = df, groupingvar = groupingvar)
missingdata <- missingdata %>% filter(p<threshold & p > 0)
if (nrow(missingdata)>0){
# KEEP ONE LINE BY GROUP
missingdata <-  missingdata %>% select(-p) %>%
group_by_(.dots = groupingvar) %>%
dplyr::mutate(x = paste(.$varia, collapse = ";")) %>%
slice(1)
lapply(1:nrow(missingdata), function(i)
interpolate_group(missingdata,i))
}
}
sapply(names(dftointerpolate), function(nam) sum(!is.na(dftointerpolate[,nam])))
dftointerpolate
i
# RECOVERING GROUPS
groupsvar <- missingdata %>% group_vars()
# ROWS THAT WILL BE CHANGED
index <- df[,groupsvar] %>% ungroup() %>%
dplyr::mutate(n = row_number()) %>%
filter_(paste(groupsvar,"==","'",missingdata[i,groupsvar],
"'", sep = "",
collapse = "&"))
# EXTRACT ROWS AND COLUMNS CONCERNED
dftointerpolate <- df[index$n,
as.character(
stringr::str_split(missingdata$x[i],pattern = ";",
simplify = T))]
# ENSURE WE DON'T HAVE EMPTY COLUMNS OR COLUMNS WITH ONLY ONE ELEMENT
dftointerpolate <- dftointerpolate[!check.emptycolumn(dftointerpolate)]
dftointerpolate
sapply(names(dftointerpolate), function(nam) sum(!is.na(dftointerpolate[,nam])))
sapply(names(dftointerpolate), function(nam) sum(!is.na(dftointerpolate[,nam])))>1
# ENSURE WE DON'T HAVE EMPTY COLUMNS OR COLUMNS WITH ONLY ONE ELEMENT
dftointerpolate <- dftointerpolate[!check.emptycolumn(dftointerpolate)]
dftointerpolate <- dftointerpolate[
sapply(names(dftointerpolate), function(nam) sum(!is.na(dftointerpolate[,nam])))>1
]
dftointerpolate
dfinterpolated <- lapply(1:ncol(dftointerpolate), function(j)
zoo::na.approx(dftointerpolate[,j],rule = 2))
dfinterpolated <- tbl_df(do.call(cbind,dfinterpolated))
dfinterpolated
# == INTERMEDIATE FUNCTION
#' DO NOT USE: Given a grouped dataframe and a line, interpolate
#'
#' @details Intermediate function, do not use
#' @param missingdata A dataframe listing groups and variables
#' that must be changed
#' @param i Line index of missingdata that will be looked
#' @return A list with several components: \code{lines} and \code{cols}
#' return the lines and columns concerned by interpolation, \code{after}
#' returns the relevant lines and columns interpolated while \code{change}
#' stores as a dummy whether data have been interpolated
#' @examples
#' # See \code{interpolate_data} source code
interpolate_group <- function(missingdata,i = 1){
# RECOVERING GROUPS
groupsvar <- missingdata %>% group_vars()
# ROWS THAT WILL BE CHANGED
index <- df[,groupsvar] %>% ungroup() %>%
dplyr::mutate(n = row_number()) %>%
filter_(paste(groupsvar,"==","'",missingdata[i,groupsvar],
"'", sep = "",
collapse = "&"))
# EXTRACT ROWS AND COLUMNS CONCERNED
dftointerpolate <- df[index$n,
as.character(
stringr::str_split(missingdata$x[i],pattern = ";",
simplify = T))]
# ENSURE WE DON'T HAVE EMPTY COLUMNS OR COLUMNS WITH ONLY ONE ELEMENT
dftointerpolate <- dftointerpolate[!check.emptycolumn(dftointerpolate)]
dftointerpolate <- dftointerpolate[
sapply(names(dftointerpolate), function(nam) sum(!is.na(dftointerpolate[,nam])))>1
]
# INTERPOLATE USING ZOO PACKAGE
dfinterpolated <- lapply(1:ncol(dftointerpolate), function(j)
zoo::na.approx(dftointerpolate[,j],rule = 2))
dfinterpolated <- tbl_df(do.call(cbind,dfinterpolated))
# CODING WE WILL USE FOR MATRIX STORING WHETHER DATA HAVE BEEN INTERPOLATE:
# NA = NOT USED FOR INTERPOLATION
# 0  = NOT INTERPOLATED BUT USED TO FILL OTHER VALUES
# 1  = INTERPOLATED
dftointerpolate <- sapply(1:ncol(dftointerpolate), function(j)
as.numeric(is.na(dftointerpolate[,j])))
# STORE IN LIST EVERYTHING THAT IS NEEDED
resultinterpol <- list(lines = index$n, cols = as.character(
stringr::str_split(missingdata$x[i],pattern = ";",
simplify = T)),
after = dfinterpolated,
change = dftointerpolate)
return(resultinterpol)
}
missingdata <- count_NAs(df = df, groupingvar = groupingvar)
missingdata <- missingdata %>% filter(p<threshold & p > 0)
missingdata <-  missingdata %>% select(-p) %>%
group_by_(.dots = groupingvar) %>%
dplyr::mutate(x = paste(.$varia, collapse = ";")) %>%
slice(1)
lapply(1:nrow(missingdata), function(i)
interpolate_group(missingdata,i))
lapply(1:nrow(missingdata), function(i) interpolate_group(missingdata,i))
fullinterpo <- lapply(1:nrow(missingdata), function(i) interpolate_group(missingdata,i))
fullinterpo
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
message = FALSE,
warning = FALSE
)
library(OpenCancer)
datadir <- paste0(getwd(),"/inst")
df_FAO <- import_FAO(path = datadir, colstokeep = 1:100)
knitr::kable(head(df_FAO[!is.na(df_FAO[,10]),1:10]))
df_WB <- import_WB(path = datadir, colstokeep = 1:100)
knitr::kable(head(df_WB[!is.na(df_WB[,6]),1:6]))
df_ILO <- import_ILO(path = datadir, colstokeep = 1:100)
knitr::kable(head(df_ILO[!is.na(df_ILO[,6]),1:6]))
#df_training <- import_training(path = datadir, colstokeep = NULL)
df_training <- import_training(path = datadir, colstokeep = NULL,
filename = "training_IARC.csv")
knitr::kable(head(na.omit(df_training)))
df_label <- import_coding()
codes <- readxl::read_excel(path = paste0(datadir,"/creation zonier.xls"),
sheet = "Transco_Country")
knitr::kable(head(codes))
df_FAO = matchkeys(df_FAO,codes)
df_WB = matchkeys(df_WB,codes,origin = "World Bank")
df_ILO = matchkeys(df_ILO,codes, origin = "IloStat")
# LEFT JOIN FAO AND WORLD BANK DATA: NO RESTRICTION TO POST 1970 DATA
df_covariates <- dplyr::full_join(df_FAO,df_WB, by = c("Country_Transco","year","Zonier"))
# JOIN AVEC ILO
df_covariates <- dplyr::left_join(df_covariates,df_ILO, by = c("Country_Transco","year","Zonier"))
# CHANGING MISMATCHED NAMES WITH TRAINING DATASET
oldnames <- unique(df_training$country[!df_training$country %in%
intersect(df_covariates$Country_Transco,df_training$country)])
newnames <- c("Netherlands","Slovakia","United States")
# IF DATAFRAME IS training.csv UNCOMMENT
#newnames <- c("Netherlands","Slovakia","United States","Gambia, The","Australian Capital Territory",
#              "South Korea","VietNam","Yugoslavia")
df_training$country <- plyr::mapvalues(df_training$country, from=oldnames, to=newnames)
# HARMONIZING COLUMN NAMES
df_training  <- df_training %>% dplyr::rename(Country_Transco = country)
df_training$ethnicity[is.na(df_training$ethnicity)] <- "All population"
df_training$region[is.na(df_training$region)] <- "All regions"
# JOIN WITH TRAINING DATASET
df_full <- dplyr::left_join(df_training,df_covariates)
# REMOVE UNNECESSARY VARIABLES
df_full <- df_full %>% select_(.dots = paste0("-", c("cancer", "area.x","area.y",
"area_code","ref_area",
"area","sourceFAO","sourceWB","sourceILO"))
)
df_full <- df_full[,!check.emptycolumn(df_full)]
knitr::kable(head(df_full[!is.na(df_full[,10]),1:10]))
pryr::mem_change(rm(df_ILO,df_FAO,df_WB,df_training,
df_covariates))
df_full <- df_full %>% filter(year>=1970)
if (sum(check.emptycolumn(df_full))>0) df_full <- check.emptycolumn(df_full)
colstokeep <- !check.emptycolumn(df_full,proportion = T)>0.4
if (!colstokeep["ethnicity"]) colstokeep["ethnicity"] <- TRUE
df_full <- df_full[,colstokeep]
check.factor(df_full,check.levels = T,threshold = 12)
df_full <- check.factor(df_full,check.levels = F,threshold = 12)
if (sum(apply(df_full[,!sapply(df_full, is.character)], 2, var, na.rm=TRUE) == 0)>0){
df_full <- df_full[,-which(apply(df_full[,!sapply(df_full, is.character)], 2, var, na.rm=TRUE) == 0)]
}
dim(df_full)
plyr::mapvalues(names(which(convert_fakezero(df_full,convert = F))),
from = df_label$code,
to = df_label$label)
potential.miscoding <-
names(which(convert_fakezero(df_full,convert = F)))
miscoded <- potential.miscoding[!potential.miscoding %in% "incidence"]
is.na(df_full[,miscoded]) <- !df_full[,miscoded]
df <- data.frame(year = c(1980,1983:1985,1990),y = rnorm(length(c(1980,1983:1985,1990))))
knitr::kable(df,caption = "Initial incomplete dataframes")
# FILL DATAFRAME
df <- fill_dataframe(df,year.var = 'year',label.var = NULL)
knitr::kable(df, caption = "Missing years have been appended")
interpo <- interpolate_data(df_full[,c(1:15, which(colnames(df_full) == "Zonier"))],
groupingvar = c("sex","age","Country_Transco", "region","ethnicity"),
year.var = 'year', label.var = 'Zonier',
threshold = 0.2)
?mapvalues
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
message = FALSE,
warning = FALSE
)
library(OpenCancer)
datadir <- paste0(getwd(),"/inst")
df_FAO <- import_FAO(path = datadir, colstokeep = 1:100)
knitr::kable(head(df_FAO[!is.na(df_FAO[,10]),1:10]))
df_WB <- import_WB(path = datadir, colstokeep = 1:100)
knitr::kable(head(df_WB[!is.na(df_WB[,6]),1:6]))
df_ILO <- import_ILO(path = datadir, colstokeep = 1:100)
knitr::kable(head(df_ILO[!is.na(df_ILO[,6]),1:6]))
#df_training <- import_training(path = datadir, colstokeep = NULL)
df_training <- import_training(path = datadir, colstokeep = NULL,
filename = "training_IARC.csv")
knitr::kable(head(na.omit(df_training)))
df_label <- import_coding()
codes <- readxl::read_excel(path = paste0(datadir,"/creation zonier.xls"),
sheet = "Transco_Country")
knitr::kable(head(codes))
df_FAO = matchkeys(df_FAO,codes)
df_WB = matchkeys(df_WB,codes,origin = "World Bank")
df_ILO = matchkeys(df_ILO,codes, origin = "IloStat")
# LEFT JOIN FAO AND WORLD BANK DATA: NO RESTRICTION TO POST 1970 DATA
df_covariates <- dplyr::full_join(df_FAO,df_WB, by = c("Country_Transco","year","Zonier"))
# JOIN AVEC ILO
df_covariates <- dplyr::left_join(df_covariates,df_ILO, by = c("Country_Transco","year","Zonier"))
# CHANGING MISMATCHED NAMES WITH TRAINING DATASET
oldnames <- unique(df_training$country[!df_training$country %in%
intersect(df_covariates$Country_Transco,df_training$country)])
newnames <- c("Netherlands","Slovakia","United States")
# IF DATAFRAME IS training.csv UNCOMMENT
#newnames <- c("Netherlands","Slovakia","United States","Gambia, The","Australian Capital Territory",
#              "South Korea","VietNam","Yugoslavia")
df_training$country <- plyr::mapvalues(df_training$country, from=oldnames, to=newnames,
warn_missing = FALSE)
# HARMONIZING COLUMN NAMES
df_training  <- df_training %>% dplyr::rename(Country_Transco = country)
df_training$ethnicity[is.na(df_training$ethnicity)] <- "All population"
df_training$region[is.na(df_training$region)] <- "All regions"
# JOIN WITH TRAINING DATASET
df_full <- dplyr::left_join(df_training,df_covariates)
# REMOVE UNNECESSARY VARIABLES
df_full <- df_full %>% select_(.dots = paste0("-", c("cancer", "area.x","area.y",
"area_code","ref_area",
"area","sourceFAO","sourceWB","sourceILO"))
)
df_full <- df_full[,!check.emptycolumn(df_full)]
knitr::kable(head(df_full[!is.na(df_full[,10]),1:10]))
pryr::mem_change(rm(df_ILO,df_FAO,df_WB,df_training,
df_covariates))
df_full <- df_full %>% filter(year>=1970)
if (sum(check.emptycolumn(df_full))>0) df_full <- check.emptycolumn(df_full)
colstokeep <- !check.emptycolumn(df_full,proportion = T)>0.4
if (!colstokeep["ethnicity"]) colstokeep["ethnicity"] <- TRUE
df_full <- df_full[,colstokeep]
head(check.factor(df_full,check.levels = T,threshold = 12))
df_full <- check.factor(df_full,check.levels = F,threshold = 12)
if (sum(apply(df_full[,!sapply(df_full, is.character)], 2, var, na.rm=TRUE) == 0)>0){
df_full <- df_full[,-which(apply(df_full[,!sapply(df_full, is.character)], 2, var, na.rm=TRUE) == 0)]
}
dim(df_full)
head(plyr::mapvalues(names(which(convert_fakezero(df_full,convert = F))),
from = df_label$code,
to = df_label$label, warn_missing = FALSE)
)
potential.miscoding <-
names(which(convert_fakezero(df_full,convert = F)))
miscoded <- potential.miscoding[!potential.miscoding %in% "incidence"]
is.na(df_full[,miscoded]) <- !df_full[,miscoded]
df <- data.frame(year = c(1980,1983:1985,1990),y = rnorm(length(c(1980,1983:1985,1990))))
knitr::kable(df,caption = "Initial incomplete dataframes")
# FILL DATAFRAME
df <- fill_dataframe(df,year.var = 'year',label.var = NULL)
knitr::kable(df, caption = "Missing years have been appended")
interpo <- interpolate_data(df_full[,c(1:15, which(colnames(df_full) == "Zonier"))],
groupingvar = c("sex","age","Country_Transco", "region","ethnicity"),
year.var = 'year', label.var = 'Zonier',
threshold = 0.2)
df_full2 <- interpo$data
conversion <- convert.character(df_full2)
names(conversion)
knitr::kable(head(conversion$data[,1:10]))
knitr::kable(head(conversion$correspondance[[1]]))
df_full2 <- conversion$data
df_full2$fakefactor <- factor(sample(1:8, size = nrow(df_full2),
replace = T))
knitr::kable(head(expand.dummies(df_full2,labelvar = "sex")))
df_full2
df = df_full2
groupingvar
groupingvar = c("sex","age","Country_Transco")
k = 1
labelvar = c("year", "Zonier")
applylag <- function(df,xvar = "1012..5322", k){
tempdf <- lapply(1:k, function(h) lag(as.numeric(unlist(df[,xvar])),h)
)
tempdf <- dplyr::tbl_df(data.frame(do.call(cbind,tempdf)))
colnames(tempdf) <- paste0(xvar,"_lag",1:k)
return(tempdf)
}
applylag.all <- function(df,k){
tempdf <- lapply(colnames(df), function(y) applylag(df,y,k))
tempdf <- dplyr::tbl_df(do.call(cbind,tempdf))
return(tempdf)
}
ccf(df_full2$`1012..5322`,df_full2$incidence)
?ccf
ccf(df_full2$`1012..5322`,df_full2$incidence,na.action = na.pass)
ccf(df_full2$`1012..5322`,df_full2$incidence,na.action = na.pass,ylab = "cross-correlation")
ccf(df_full2$`1012..5322`,df_full2$incidence,na.action = na.pass,ylab = "cross-correlation",)
ccf(df_full2$`1012..5322`,df_full2$incidence,na.action = na.pass,ylab = "cross-correlation",plot = F)
ccf(df_full2$`1012..5417`,df_full2$incidence,na.action = na.pass,ylab = "cross-correlation",plot = F)
factorvar <- which(sapply(df_full2,is.factor))
factorvar <- factorvar[-which(names(factorvar) == 'sex')]
factorvar
cbind(df[,-factorvar],expand.dummies(df_full2,labelvar = "sex"))
?createlag
df_full2
createlag(df_full2, groupingvar = c("sex","age","Country_Transco",
"region","ethnicity"), k = 1)
df_full2[1:8]
createlag(df_full2[1:8], groupingvar = c("sex","age","Country_Transco",
"region","ethnicity"), k = 2)
df_full2 <- createlag(df_full2[1:8], groupingvar = c("sex","age","Country_Transco",
"region","ethnicity"), k = 2,
labelvar = c("year","incidence"))
df_full2
?attach.big.matrix
df_full2
df_full
df_full[,1:15]
X <- df_full[,1:15]
X
convert.character(X)
X <- convert.character(X)$data
X
X
X <- as.big.matrix(df_full)
X <- as.big.matrix(data.frame(df_full))
X <- df_full[,1:15]
X <- convert.character(X)$data
X <- as.big.matrix(data.frame(X))
X
X <- df_full[,1:15]
X <- convert.character(X)$data
Y <- as.big.matrix(data.frame(X))
Y
X
performPreProcess(Y, groupingvar = c("sex","age","Country_Transco",
"region","ethnicity"),
labelvar = "year")
performPreProcess <- function(X,groupingvar = c("sex","age","Country_Transco"),
labelvar = c("year", "Zonier")){
options(bigmemory.allow.dimnames=TRUE)
if (length(c(groupingvar,labelvar))>0){
data <- deepcopy(X, cols = !(colnames(X) %in% c(groupingvar,labelvar)))
colnames(data) <- colnames(X)[!(colnames(X) %in% c(groupingvar,labelvar))]
preProc <- caret::preProcess(data[,])
} else{
preProc <- caret::preProcess(X[,])
}
return(preProc)
}
performPreProcess(Y, groupingvar = c("sex","age","Country_Transco",
"region","ethnicity"),
labelvar = "year")
?preProcess
preprocess.model <- performPreProcess(Y, groupingvar = c("sex","age","Country_Transco",
"region","ethnicity"),
labelvar = "year")
predict(preprocess.model,X$`1012..5510`)
predict(preprocess.model,X)
predict(preprocess.model,Y)
predict(preprocess.model,X$`1035..5417`)
X
X
paste0("X",colnames(X))
X[,paste0("X",colnames(X))] <- X[,colnames(X)]
predict(preprocess.model,X$`1035..5417`)
install.packages("C:/Users/linog/Google Drive/4A ENS/Epidemium/OpenCancer_0.1.0.tar.gz", type = 'source',repos = NULL)
browseVignettes("OpenCancer")
paste0("^",cancercode,"$")
browseVignettes("OpenCancer")
?import_FAO
